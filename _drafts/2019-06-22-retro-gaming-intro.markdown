---
layout: post
title:  "A look at retro gaming"
comments: true
categories: compiler llvm
---

Back when I was a kid in the late 80's early 90's I had a [Commodore
64](https://en.wikipedia.org/wiki/Commodore_64), a [Amiga
500](https://en.wikipedia.org/wiki/Amiga_500) and eventually a [Amiga
1200](https://en.wikipedia.org/wiki/Amiga_1200). Now besides playing games and
calling [BBS](https://en.wikipedia.org/wiki/Bulletin_board_system)s I never got
around to do any programming on these devices.  Something that I quite regret
now in grown age when I realize how beautiful, and in a way simple, these
machines were. Well to be honest I did play around a bit with
[BASIC](https://en.wikipedia.org/wiki/BASIC) but I never really got a hang of
it and hence never became hooked. It wasn't until years later when I learned C that
I finally started to understand how a computer works.

Not too long ago I read about the
[MiSTer](https://github.com/MiSTer-devel/Main_MiSTer/wiki) project and while I
have known about the [Minimig](https://en.wikipedia.org/wiki/Minimig) for a
long time it wasn't until now it appeared to be running on almost off the shelf
hardware. This and seeing Youtube videos of people reverse engineering old
arcade PCBs (e.g.  [this](https://www.youtube.com/watch?v=g8gZT1F9UkE) one)
inspired me to look into this field again.

I also found a nice little book called [Designing Video Game Hardware in
Verilog](https://www.amazon.com/dp/B07LD48CTV/ref=pe_385040_118058080_TE_M1DP)
by a guy named Steven Hugg. The Kindle version sells for $12 and I highly
recommend this book, not because it is great and contains tons of stuff you
didn't already know or could not figure out yourself but because it is a nice
read with interesting historical remarks and it comes with a website called
[8bitworkshops](https://8bitworkshop.com/) that is pretty awesome and
is coincidently also the topic of this blog post.

Now the website can actually be fully used without purchasing the book but I
really think it is an effort worth supporting. 

While the website allows you to interactively program and run old arcade
systems and consoles such as the Atari 2600 in both C and assembler what totally
blew my mind is the ability to write a custom hardware design in Verilog
producing a VGA video signal and then having that run in the browser displaying
graphics on a simulated CRT (and with a pretty impressive frame rate too). 

To me that all seemed fictional, did this guy actually implement a complete
Verilog simulator in JavaScript that runs that fast? Well it turns out that he
did not but instead used existing software in a really clever way and this post
will try to shed some light on how.

First, the source code behind the entire 8bitworkshops website is available on
Github [here](https://github.com/sehugg/8bitworkshop).

To pull off the Verilog stunt described above it uses mainly two components:

* [Emscripten](https://emscripten.org/) - a LLVM backend that generates
  JavaScript effectively allowing you to compile C++ code into JavaScript and
  execute in a browser.
* [Verilator](https://www.veripool.org/wiki/verilator) - a verilog simulator
  that compiles synthesizable verilog modules into C++ code.

Now Verilator is compiled into JavaScript by Emscripten so Verilator will run
in you browser outputting C++ code for the Verilog modules you provide. The
question is now of course what happens with this Verilator generated C++. One
option would be if Emscripten 'Emsripted' itself so that your browser had the
ability to turn C++ into JavaScript but that is not what is happening. The C++
generated by Verilator only uses a subset of the full language and is quite
regular and the fact that this subset is quite similar (expect for some syntax
details) to JavaScript is used to to simply do some regexp based translations.


Verilated C++ is translated into JavaScript by
[src/worker/verilator2js.ts](https://github.com/sehugg/8bitworkshop/blob/10f89d0c53e610934b0035bbed5a4af258844786/src/worker/verilator2js.ts).

If one studies an example of how to use Verilator natively in C++ then one can
see that pattern being hand translated to JS in
[src/platform/verilog.ts](https://github.com/sehugg/8bitworkshop/blob/10f89d0c53e610934b0035bbed5a4af258844786/src/platform/verilog.ts).
Especially the function
[updateVideoFrameCycles](https://github.com/sehugg/8bitworkshop/blob/10f89d0c53e610934b0035bbed5a4af258844786/src/platform/verilog.ts#L496-L539)
calls vidtick (calling tick2 to toggle the clock and advance simulation) and
extracting VGA signals from the model, storing to a JS frame buffer for display
on the web page.

